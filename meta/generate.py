#!/usr/bin/env python3

import os, sys
from os import path

def generate(line, outLines):

    # parse the argument list into a dict
    args = dict([arg.split(":") for arg in line.split() if ":" in arg])

    # load the metatemplate
    with open(path.join("meta", args["AUTOGENERATED"]), "r") as inFile:
        metaLines = inFile.readlines()

    # skip license
    start = 0
    for i in range(len(metaLines)):
        if metaLines[i].startswith("//!!! END_LICENSE"):
            start = i + 1
            break

    # substitute metatemplate parameters
    for i in range(start, len(metaLines)):
        for key, value in args.items():
            if key == "AUTOGENERATED":
                continue
            metaLines[i] = metaLines[i].replace("{" + key + "}", value)

    # output the data
    lines = ["// This block is auto-generated. Do not modify until END_AUTOGENERATED.\n"]
    lines += metaLines[start:]
    outLines += [(("    " + line).rstrip() + "\n") for line in lines]


def parse(path, clean):
    # print a parsing message, helps with debugging
    parsingMessage = 'Parsing ' + path + "   "
    print(parsingMessage, end='', flush=True)

    with open(path, "r") as inFile:
        inLines = inFile.readlines()

    found = False
    outLines = []
    i = 0

    while i < len(inLines):
        line = inLines[i]

        # find the next auto-generated block
        if line.startswith("//!!! AUTOGENERATED:"):
            found = True
            outLines.append(line)

            # output the template (unless we're cleaning, in which case we completely leave it out)
            if not clean:
                generate(line, outLines)

            # skip lines until END_AUTOGENERATED
            while True:
                i += 1
                if i == len(inLines):
                    raise Exception("Missing END_AUTOGENERATED block before end of file!")
                skip = inLines[i]
                if skip.startswith("//!!! AUTOGENERATED"):
                    raise Exception("Missing END_AUTOGENERATED block before next AUTOGENERATED block!")
                if skip.startswith("//!!! END_AUTOGENERATED"):
                    line = skip
                    break

        outLines.append(line)
        i += 1

    # erase the parsing message
    print('\r' + ' ' * len(parsingMessage) + '\r', end='')

    # if we didn't find any auto-generated blocks, nothing to do
    if not found:
        return False

    # if the file hasn't change, mention it and nothing to do
    if inLines == outLines:
        #print("No change: " + path)
        return False

    # write the new file
    print("Meta-templates changed: " + path)
    temp = path + ".temp"
    with open(temp, "w") as outFile:
        outFile.writelines(outLines)
    os.replace(temp, path)
    return True

def go(include, clean):
    changes = False
    for root, dirs, files in os.walk(include):
        for filename in files:
            if filename.endswith(".h") or filename.endswith(".hxx"):
                changes |= parse(path.join(root, filename), clean)

    # mark the changes so the CI can tell if anything's changed
    build = path.join("test", "build")
    changefile = path.join(build, "meta_changed")
    if changes:
        os.makedirs(build, exist_ok=True)
        open(changefile, "w").close()
    else:
        try:
            os.remove(changefile)
        except OSError:
            pass

if __name__ == "__main__":

    # command-line arguments can clean headers and/or generate headers elsewhere
    clean = False
    foundPaths = False
    for arg in sys.argv[1:]:
        if arg == "-c":
            clean = True
        else:
            go(arg, clean)
            foundPaths = True

    # default paths if none were specified
    if not foundPaths:
        go("include", clean)
        go("bindings/cxx/include", clean)

